unit DeltaModel.ORM.DDL;

{$mode ObjFPC}{$H+}

interface

uses
  Classes, SysUtils, TypInfo, Variants,
  DeltaModel, DeltaModel.Fields, DeltaModel.ORM.Types;

type

  { TDDLBuilder }

  TDDLBuilder = class
  protected
    class function FieldDDL(DeltaField: TDeltaField; ADialect: TDatabaseDialect): string;
    class function ForeignKeyDDL(const Table: string; DeltaField: TDeltaField;
      ADialect: TDatabaseDialect): string;
    class function PrimitiveFieldDDL(Name: string; Kind: TTypeKind; ADialect: TDatabaseDialect): string;
    class procedure GetFieldsCT(Obj: TDeltaModel; ADialect: TDatabaseDialect; List: TStrings);
    class procedure GetConstraintsCT(Obj: TDeltaModel; ADialect: TDatabaseDialect; List: TStrings);
    class procedure GetFieldsAT(Obj: TDeltaModel; ADialect: TDatabaseDialect; List, ActualFieldList, Constraints: TStrings);
  public
    class function CreateTableAndFields(Obj: TDeltaModel; Constraints: TStrings; ADialect: TDatabaseDialect): string;
    class function CreateFields(Obj: TDeltaModel; ADialect: TDatabaseDialect; ActualFieldList, Constraints: TStrings): string;
  end;

implementation

{ TDDLBuilder }

class function TDDLBuilder.FieldDDL(DeltaField: TDeltaField;
  ADialect: TDatabaseDialect): string;
var
  SQLType, AutoInc: string;
  Size: Integer;
begin
  SQLType := EmptyStr;
  AutoInc := EmptyStr;

  if (DeltaField is TDFIntNull) or (DeltaField is TDFIntRequired) then
  begin
    SQLType := 'INTEGER';
  end
  else
  if (DeltaField is TDFCurrencyNull) or (DeltaField is TDFCurrencyRequired) or
     (DeltaField is TDFDoubleNull) or (DeltaField is TDFDoubleRequired) then
  begin
    case ADialect of
      ddFirebird: SQLType   := 'DOUBLE PRECISION';
      ddSQLite: SQLType     := 'REAL';
      ddPostgreSQL: SQLType := 'DOUBLE PRECISION';
    end;
  end
  else
  if (DeltaField is TDFStringNull) or (DeltaField is TDFStringRequired) then
  begin
    if (DeltaField is TDFStringNull) then
      Size := (DeltaField as TDFStringNull).Size
    else
      Size := (DeltaField as TDFStringRequired).Size;

    case ADialect of
      ddSQLite: SQLType := 'TEXT';
    else
      SQLType := Format('VARCHAR(%d)', [Size]);
    end;
  end;

  if SQLType.IsEmpty then
    raise Exception.CreateFmt('Field %s has an invalid datatype for DDL.', [DeltaField.ClassName]);

  if (dboAutoInc in DeltaField.DBOptions) then
  begin
    case ADialect of
      ddFirebird:
        AutoInc := 'GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY';
      ddPostgreSQL:
        AutoInc := 'SERIAL PRIMARY KEY';
      ddSQLite:
        AutoInc := 'PRIMARY KEY AUTOINCREMENT';
    else
      AutoInc := '';
    end;
  end;

  if (dboAutoInc in DeltaField.DBOptions) then
  begin
    Result := Format('%s %s %s', [DeltaField.FieldName, SQLType, AutoInc]);
  end
  else if (dboPrimaryKey in DeltaField.DBOptions) then
  begin
    Result := Format('%s %s PRIMARY KEY NOT NULL', [DeltaField.FieldName, SQLType]);
  end
  else if (DeltaField is TDeltaFieldNullable) then
  begin
    Result := Format('%s %s', [DeltaField.FieldName, SQLType]);
  end
  else
  begin
    Result := Format('%s %s NOT NULL', [DeltaField.FieldName, SQLType]);
  end;
end;


class function TDDLBuilder.ForeignKeyDDL(const Table: string; DeltaField: TDeltaField;
  ADialect: TDatabaseDialect): string;
var
  FKName, RefTable, RefField: string;
  OnDeleteClause, OnUpdateClause: string;
  Obj: TObject;
begin
  if ADialect in [ddSQLite] then
  begin
    //don't support alter table to create FK. Need to create a table with constraints
    Exit('');
  end;

  RefField := DeltaField.ForeignKey.ReferencesField;
  Obj := DeltaField.ForeignKey.ReferencesTable.Create;
  try
    RefTable := (Obj as TDeltaModel).TableName;
  finally
    Obj.Free;
  end;

  case DeltaField.ForeignKey.OnDelete of
    fkCascade: OnDeleteClause := ' ON DELETE CASCADE';
    fkSetNull: OnDeleteClause := ' ON DELETE SET NULL';
    fkRestrict: OnDeleteClause := ' ON DELETE RESTRICT';
    fkNone: OnDeleteClause := ' ON DELETE NO ACTION';
  else
    OnDeleteClause := '';
  end;

  case DeltaField.ForeignKey.OnUpdate of
    fkCascade: OnUpdateClause := ' ON UPDATE CASCADE';
    fkSetNull: OnUpdateClause := ' ON UPDATE SET NULL';
    fkRestrict: OnUpdateClause := ' ON UPDATE RESTRICT';
    fkNone: OnUpdateClause := ' ON UPDATE NO ACTION';
  else
    OnUpdateClause := '';
  end;

  FKName := Format('FK_%s_%s', [Table, RefTable]);
  FKName := Copy(FKName, 1, 31); //to avoid overflow

  Result := Format(
    'ALTER TABLE %s ADD CONSTRAINT %s ' +
    'FOREIGN KEY (%s) REFERENCES %s(%s)%s%s',
    [Table, FKName, DeltaField.FieldName, RefTable, RefField, OnDeleteClause, OnUpdateClause]
  );
end;

class function TDDLBuilder.PrimitiveFieldDDL(Name: string; Kind: TTypeKind;
  ADialect: TDatabaseDialect): string;
var
  SQLType: string;
begin
  case Kind of
    tkInteger, tkInt64, tkEnumeration:
    begin
      SQLType := 'INTEGER';
    end;

    tkBool:
    begin
      SQLType := 'BOOLEAN';
    end;

    tkFloat:
    begin
      case ADialect of
        ddFirebird: SQLType   := 'DOUBLE PRECISION';
        ddSQLite: SQLType     := 'REAL';
        ddPostgreSQL: SQLType := 'DOUBLE PRECISION';
      end;
    end;
  else
    case ADialect of
      ddSQLite: SQLType := 'TEXT';
    else
      SQLType := 'VARCHAR(255)';
    end;
  end;

  Result := Format('%s %s NOT NULL', [Name, SQLType]);
end;

class procedure TDDLBuilder.GetFieldsCT(Obj: TDeltaModel;
  ADialect: TDatabaseDialect; List: TStrings);
var
  PropList: PPropList;
  PropInfo: PPropInfo;
  PropCount, I: Integer;
  DeltaField: TDeltaField;
begin
  PropCount := GetPropList(Obj.ClassInfo, tkProperties, nil);
  if PropCount = 0 then Exit;
  GetMem(PropList, PropCount * SizeOf(Pointer));
  try
    GetPropList(Obj.ClassInfo, tkProperties, PropList, False);
    for I := 0 to PropCount - 1 do
    begin
      PropInfo := PropList^[I];
      if (TObject(GetObjectProp(Obj, PropInfo)) is TDeltaField) then
      begin
        DeltaField := TDeltaField(GetObjectProp(Obj, PropInfo));
        List.Add(sLineBreak + '  ' + FieldDDL(DeltaField, ADialect));
      end
      else
      begin
        List.Add(sLineBreak + '  ' + PrimitiveFieldDDL(PropInfo^.Name, PropInfo^.PropType^.Kind, ADialect));
      end;
    end;
  finally
    FreeMem(PropList, PropCount * SizeOf(Pointer));
  end;
end;

class procedure TDDLBuilder.GetConstraintsCT(Obj: TDeltaModel;
  ADialect: TDatabaseDialect; List: TStrings);
var
  PropList: PPropList;
  PropInfo: PPropInfo;
  PropCount, I: Integer;
  DeltaField: TDeltaField;
begin
  PropCount := GetPropList(Obj.ClassInfo, tkProperties, nil);
  if PropCount = 0 then Exit;
  GetMem(PropList, PropCount * SizeOf(Pointer));
  try
    GetPropList(Obj.ClassInfo, tkProperties, PropList, False);
    for I := 0 to PropCount - 1 do
    begin
      PropInfo := PropList^[I];
      if not (TObject(GetObjectProp(Obj, PropInfo)) is TDeltaField) then
      begin
        Continue;
      end;

      DeltaField := TDeltaField(GetObjectProp(Obj, PropInfo));

      if (DeltaField.ForeignKey.ReferencesTable <> nil) then
      begin
        if (DeltaField.ForeignKey.ReferencesTable <> TDeltaModel) then
        begin
          raise Exception.CreateFmt('%s foreign key references a non TDeltaModel class.', [DeltaField.ClassName]);
        end;

        List.Add(ForeignKeyDDL(Obj.TableName, DeltaField, ADialect));
      end;
    end;
  finally
    FreeMem(PropList, PropCount * SizeOf(Pointer));
  end;
end;

class procedure TDDLBuilder.GetFieldsAT(Obj: TDeltaModel;
  ADialect: TDatabaseDialect; List, ActualFieldList, Constraints: TStrings);
const
  ADD_COLUMN = sLineBreak + '  ADD COLUMN ';
var
  PropList: PPropList;
  PropInfo: PPropInfo;
  PropCount, I: Integer;
  DeltaField: TDeltaField;
begin
  PropCount := GetPropList(Obj.ClassInfo, tkProperties, nil);
  if PropCount = 0 then Exit;
  GetMem(PropList, PropCount * SizeOf(Pointer));
  try
    GetPropList(Obj.ClassInfo, tkProperties, PropList, False);
    for I := 0 to PropCount - 1 do
    begin
      PropInfo := PropList^[I];
      if (TObject(GetObjectProp(Obj, PropInfo)) is TDeltaField) then
      begin
        DeltaField := TDeltaField(GetObjectProp(Obj, PropInfo));
        if ActualFieldList.IndexOf(DeltaField.FieldName) = -1 then
        begin
          List.Add(ADD_COLUMN + FieldDDL(DeltaField, ADialect));

          if (DeltaField.ForeignKey.ReferencesTable <> nil) then
          begin
            if not (DeltaField.ForeignKey.ReferencesTable <> TDeltaModel) then
            begin
              raise Exception.CreateFmt('%s foreign key references a non TDeltaModel class.', [DeltaField.ClassName]);
            end;

            Constraints.Add(ForeignKeyDDL(Obj.TableName, DeltaField, ADialect));
          end;
        end;
      end
      else
      begin
        if ActualFieldList.IndexOf(PropInfo^.Name) = -1 then
          List.Add(ADD_COLUMN + PrimitiveFieldDDL(PropInfo^.Name, PropInfo^.PropType^.Kind, ADialect));
      end;
    end;
  finally
    FreeMem(PropList, PropCount * SizeOf(Pointer));
  end;
end;

class function TDDLBuilder.CreateTableAndFields(Obj: TDeltaModel;
  Constraints: TStrings; ADialect: TDatabaseDialect): string;
var
  SQL, Fields: TStringList;
  Option: string;
begin
  SQL := TStringList.Create;
  Fields := TStringList.Create;
  try
    Fields.Delimiter := ',';
    Fields.StrictDelimiter := True;
    GetFieldsCT(Obj, ADialect, Fields);

    case ADialect of
      ddSQLite: Option := 'IF NOT EXISTS ';
    else
      Option := EmptyStr;
    end;

    SQL.Add(
      'CREATE TABLE ' + Option + Obj.TableName + ' (' +
      Fields.DelimitedText + sLineBreak +
      ');'
    );

    Result := SQL.Text;
  finally
    SQL.Free;
    Fields.Free;
  end;
end;

class function TDDLBuilder.CreateFields(Obj: TDeltaModel;
  ADialect: TDatabaseDialect; ActualFieldList, Constraints: TStrings): string;
var
  SQL, Fields: TStringList;
begin
  Result := EmptyStr;

  SQL := TStringList.Create;
  Fields := TStringList.Create;
  try
    Fields.Delimiter := ',';
    Fields.StrictDelimiter := True;
    GetFieldsAT(Obj, ADialect, Fields, ActualFieldList, Constraints);

    SQL.Add(
      'ALTER TABLE ' + Obj.TableName + sLineBreak +
      Fields.DelimitedText + sLineBreak + ';'
    );

    if Fields.Count > 0 then
    begin
      Result := SQL.Text;
    end;
  finally
    SQL.Free;
    Fields.Free;
  end;
end;

end.

